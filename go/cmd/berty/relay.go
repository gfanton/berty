package main

import (
	"context"
	crand "crypto/rand"
	"encoding/base64"
	"flag"
	"strings"
	"time"

	// nolint:staticcheck
	"github.com/ipfs/go-datastore"
	dsync "github.com/ipfs/go-datastore/sync"
	libp2p "github.com/libp2p/go-libp2p"
	circuit "github.com/libp2p/go-libp2p-circuit"
	relay "github.com/libp2p/go-libp2p-circuit/v2/relay"
	libp2p_ci "github.com/libp2p/go-libp2p-core/crypto"
	host "github.com/libp2p/go-libp2p-core/host"
	"github.com/libp2p/go-libp2p-core/peer"
	routing "github.com/libp2p/go-libp2p-core/routing"
	dht "github.com/libp2p/go-libp2p-kad-dht"
	libp2p_quic "github.com/libp2p/go-libp2p-quic-transport"
	"github.com/libp2p/go-libp2p/config"
	ma "github.com/multiformats/go-multiaddr"
	"github.com/peterbourgon/ff/v3/ffcli"
	"go.uber.org/zap"

	"berty.tech/berty/v2/go/internal/ipfsutil"
	"berty.tech/berty/v2/go/pkg/errcode"
)

func relayServerCommand() *ffcli.Command {
	var (
		serveListeners = "/ip4/0.0.0.0/tcp/4040,/ip4/0.0.0.0/udp/4141/quic"
		servePK        = ""
		serveAnnounce  = ""
	)

	fsBuilder := func() (*flag.FlagSet, error) {
		fs := flag.NewFlagSet("berty relay", flag.ExitOnError)
		fs.String("config", "", "config file (optional)")
		manager.SetupLoggingFlags(fs) // also available at root level

		fs.StringVar(&serveAnnounce, "announce", serveAnnounce, "addrs that will be announce by this server")
		fs.StringVar(&serveListeners, "listeners", serveListeners, "lists of listeners of (m)addrs separate by a comma")
		fs.StringVar(&servePK, "pk", servePK, "private key (generated by `relay genkey`)")

		return fs, nil
	}

	return &ffcli.Command{
		Name:           "relay",
		ShortHelp:      "setup ipfs relay",
		ShortUsage:     "berty [global flags] repl-server [flags]",
		FlagSetBuilder: fsBuilder,
		UsageFunc:      usageFunc,
		Options:        ffSubcommandOptions(),
		Exec: func(ctx context.Context, args []string) error {
			if len(args) > 0 {
				return flag.ErrHelp
			}

			var err error

			logger, err := manager.GetLogger()
			if err != nil {
				return err
			}

			// load existing or generate new identity
			var priv libp2p_ci.PrivKey
			if servePK != "" {
				kBytes, err := base64.StdEncoding.DecodeString(servePK)
				if err != nil {
					return errcode.TODO.Wrap(err)
				}
				priv, err = libp2p_ci.UnmarshalPrivateKey(kBytes)
				if err != nil {
					return errcode.TODO.Wrap(err)
				}
			} else {
				// Don't use key params here, this is a dev tool, a real installation should use a static key.
				priv, _, err = libp2p_ci.GenerateKeyPairWithReader(libp2p_ci.Ed25519, -1, crand.Reader) // nolint:staticcheck
				if err != nil {
					return errcode.TODO.Wrap(err)
				}
			}

			laddrs := strings.Split(serveListeners, ",")
			mlisteners, err := ipfsutil.ParseAddrs(laddrs...)
			if err != nil {
				return errcode.TODO.Wrap(err)
			}

			var addrsFactory config.AddrsFactory = func(ms []ma.Multiaddr) []ma.Multiaddr { return ms }
			if serveAnnounce != "" {
				aaddrs := strings.Split(serveAnnounce, ",")
				announces, err := ipfsutil.ParseAddrs(aaddrs...)
				if err != nil {
					return errcode.TODO.Wrap(err)
				}

				addrsFactory = func([]ma.Multiaddr) []ma.Multiaddr { return announces }
			}

			// @TODO(gfanton): add resource limiter as opt
			l := relay.DefaultLimit()
			l.Duration = 10 * time.Minute
			l.Data = 0 // remove data limit

			rc := relay.DefaultResources()
			rc.Limit = l

			logger.Debug("starting relay")

			var routing config.RoutingC = func(h host.Host) (routing.PeerRouting, error) {
				dsA := dsync.MutexWrap(datastore.NewMapDatastore())
				return dht.NewDHT(ctx, h, dsA), nil
			}

			// init p2p host
			h, err := libp2p.New(ctx,
				// default tpt + quic
				libp2p.DefaultTransports,
				libp2p.Transport(libp2p_quic.NewTransport),

				libp2p.Routing(routing),

				// Nat & Relay service
				libp2p.EnableRelay(circuit.OptHop),
				libp2p.EnableAutoRelay(),
				libp2p.DefaultStaticRelays(),
				libp2p.RelayV2Options(relay.WithResources(rc)),

				// swarm listeners
				libp2p.ListenAddrs(mlisteners...),

				// identity
				libp2p.Identity(priv),

				// announce
				libp2p.AddrsFactory(addrsFactory),
			)

			if err != nil {
				return err
			}
			defer h.Close()

			addrs, err := peer.AddrInfoToP2pAddrs(&peer.AddrInfo{
				ID:    h.ID(),
				Addrs: h.Addrs(),
			})

			if err != nil {
				return err
			}

			for _, maddr := range addrs {
				logger.Info("Host Addrs", zap.String("maddr", maddr.String()))
			}

			return manager.RunWorkers()
		},
	}
}
